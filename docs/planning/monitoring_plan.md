# 모니터링 시스템 기술 명세서

## 1. 개요

### 1.1 프로젝트 배경

10인 미만의 PLC 및 하드웨어 전장 설계 회사를 위한 경량 ERP 시스템의 안정적인 운영을 위한 모니터링 시스템이다.

### 1.2 설계 원칙

- **경량성**: 제한된 하드웨어 자원 내에서 동작
- **직관성**: 복잡한 기능보다 핵심 기능에 집중
- **독립성**: ERP 장애 시에도 모니터링 및 알람 가능

### 1.3 목표

노트북의 한정된 자원 안에서 서비스가 안전하게 동작하기 위한 모니터링 시스템 구축

---

## 2. 인프라 환경

### 2.1 배포 환경

| 항목 | 사양 |
|------|------|
| 배포 방식 | 온프레미스 (사무실 내 노트북) |
| 서버 | 노트북 |
| CPU | Intel i5-10219U |
| RAM | 8GB |
| SSD | SAMSUNG MZVLB256HBHQ |
| GPU | Intel UHD Graphics |

### 2.2 자원 제약 분석

8GB RAM 환경에서 다음 서비스들이 동시 운영된다:

| 서비스 | 예상 메모리 |
|--------|-------------|
| Docker 데몬 | ~500MB |
| PostgreSQL 컨테이너 | ~500MB |
| Backend 컨테이너 | ~500MB |
| Frontend 컨테이너 | ~200MB |
| Nginx 컨테이너 | ~50MB |
| GitHub Runner | ~300MB |
| OS 및 기타 | ~2GB |
| **합계** | **~4GB** |

**결론**: 모니터링 시스템은 100~150MB 이내로 유지해야 함

---

## 3. 아키텍처 결정

### 3.1 ERP 통합 vs 분리

#### 검토 옵션

| 구분 | ERP에 통합 | 별도 분리 |
|------|-----------|-----------|
| 추가 RAM | 0 | ~100~150MB |
| 관리 포인트 | 1개 | 2개 |
| ERP 장애 시 | 알람 불가 ❌ | 알람 가능 ✅ |

#### 결정: 별도 분리

**근거**: 모니터링의 핵심 목적은 장애 감지 및 알람이다. ERP가 다운되면 모니터링도 함께 다운되어 알람을 받을 수 없다면, 모니터링 시스템의 존재 의미가 없다.

```
ERP 다운 → 모니터링도 다운 → 알람 없음 → 장애 인지 불가
```

### 3.2 실무 모니터링 스택과의 비교

#### 실무 풀스택 구성 (참고)

| 도구 | 역할 | 필요 RAM |
|------|------|----------|
| Prometheus | 메트릭 수집/저장 | 2~4GB |
| Grafana | 시각화 | 1GB |
| Elasticsearch | 로그 저장 | 8GB (최소) |
| Kibana | 로그 시각화 | 1GB |
| Alertmanager | 알람 | 500MB |
| **합계** | | **12~15GB** |

#### 결정: 경량 커스텀 구현

**근거**:
1. 8GB 노트북에서 ERP + DB + 실무 풀스택 = 물리적으로 불가능
2. 단일 서버 환경에서 분산 추적(Jaeger/Pinpoint) 불필요
3. 시계열 데이터 장기 보관 불필요 (과거 추이 분석보다 즉시 알람이 중요)
4. 온콜 로테이션 불필요 (알람 수신자 = 1인)

**접근 방식**: 실무 스택의 20% 기능으로 80% 문제 해결

---

## 4. 기술 스택

### 4.1 기술 스택 요약

| 영역 | 기술 | 선정 이유 |
|------|------|-----------|
| 언어/프레임워크 | Kotlin / Spring Boot | 기존 ERP와 동일, 학습 비용 없음 |
| 시스템 리소스 수집 | OSHI | JVM 네이티브, 배터리/전원 상태 지원 |
| Docker 모니터링 | docker-java | Java/Kotlin 네이티브 Docker API 클라이언트 |
| GitHub Runner 모니터링 | GitHub REST API | 공식 API, PAT 인증 |
| 스케줄링 | @Scheduled | Spring 기본 기능, 추가 의존성 없음 |
| 에러 캐치 | @ControllerAdvice | Spring 기본 기능 |
| 알람 발송 | WebClient → Slack Webhook | 경량, 즉시 푸시 |
| 대시보드 | Spring MVC (웹) | 원격 접근 가능 |
| 접근 제어 | IP 화이트리스트 필터 | 단순하고 효과적 |

### 4.2 상세 기술 선정 근거

#### 4.2.1 시스템 리소스 수집: OSHI

**검토 옵션**:
- OSHI (Operating System and Hardware Information)
- JMX (Java Management Extensions)
- 쉘 스크립트 호출

**선정: OSHI**

| 근거 | 설명 |
|------|------|
| 통합성 | CPU, RAM, 디스크, 배터리, 전원 상태를 단일 라이브러리로 수집 |
| 경량성 | 메모리 점유 ~5MB |
| 호환성 | Java/Kotlin 네이티브, 별도 프로세스 불필요 |
| 기능성 | 노트북 특수 요구사항(배터리, 전원 상태) 지원 |

```kotlin
// 의존성
implementation("com.github.oshi:oshi-core:6.4.0")
```

#### 4.2.2 Docker 모니터링: docker-java

**검토 옵션**:
- docker-java 라이브러리
- Docker CLI 호출 (ProcessBuilder)
- Docker REST API 직접 호출

**선정: docker-java**

| 근거 | 설명 |
|------|------|
| 타입 안정성 | Kotlin/Java 객체로 응답 매핑 |
| 기능성 | 컨테이너 상태, 리소스 사용량, 이벤트 구독 지원 |
| 유지보수성 | CLI 파싱보다 안정적 |

#### 4.2.3 알람 채널: Slack Webhook

**검토 옵션**:

| 채널 | 장점 | 단점 |
|------|------|------|
| 대시보드 알람만 | 구현 간단 | 안 보면 모름 |
| 이메일 (SMTP) | 기록 남음 | 지연, 스팸함 위험 |
| 텔레그램 봇 | 즉시 푸시 | 별도 앱 설치 |
| Slack Webhook | 즉시 푸시, 업무용 | Slack 사용 전제 |

**선정: Slack Webhook**

| 근거 | 설명 |
|------|------|
| 즉시성 | 모바일 푸시로 즉시 알림 수신 |
| 업무 통합 | 업무용 메신저로 별도 앱 불필요 |
| 구현 용이성 | HTTP POST 한 번으로 발송 완료 |
| 비용 | 무료 |

#### 4.2.4 대시보드: 웹 (Spring MVC)

**검토 옵션**:

| 방식 | 장점 | 단점 |
|------|------|------|
| Swing (데스크톱) | 네이티브, 빠름 | 원격 접근 불가, 별도 프로세스 |
| 웹 | 원격 접근, 추가 프로세스 없음 | 프론트 작업 필요 |

**선정: 웹**

| 근거 | 설명 |
|------|------|
| 원격 접근 | 외부에서 브라우저로 상태 확인 가능 |
| 통합성 | 모니터링 서비스 내 엔드포인트로 구현 |
| 유지보수 | 별도 GUI 프로세스 관리 불필요 |

#### 4.2.5 접근 제어: IP 화이트리스트

**검토 옵션**:
- Spring Security + 로그인
- IP 화이트리스트
- Basic Auth

**선정: IP 화이트리스트**

| 근거 | 설명 |
|------|------|
| 단순성 | 경량 ERP 원칙에 부합 |
| 보안성 | 내부망 운영 환경에서 충분 |
| 구현 용이성 | Filter 하나로 구현 완료 |

#### 4.2.6 배포 방식: JAR + systemd

**검토 옵션**:

| 방식 | 장점 | 단점 |
|------|------|------|
| Docker 컨테이너 | 기존과 동일한 관리 | Docker 의존 |
| JAR + systemd | Docker 없이도 동작 | systemd 설정 필요 |

**선정: JAR + systemd**

| 근거 | 설명 |
|------|------|
| 독립성 | Docker 데몬 장애 시에도 모니터링 동작 |
| 안정성 | systemd가 프로세스 자동 재시작 관리 |
| 부팅 연동 | 시스템 부팅 시 자동 시작 |

---

## 5. 모니터링 대상 및 정책

### 5.1 모니터링 항목

| 대상 | 수집 방식 | 주기 | 알람 조건 | 알람 레벨 |
|------|-----------|------|-----------|-----------|
| CPU | 폴링 | 1분 | > 80% | ⚠️ 경고 |
| RAM | 폴링 | 1분 | > 80% | ⚠️ 경고 |
| SSD | 폴링 | 5분 | > 80% | ⚠️ 경고 |
| 배터리 | 폴링 | 1분 | < 20% (미연결 시) | ⚠️ 경고 |
| Docker 데몬 | 폴링 | 30초 | 다운 | 🔴 장애 |
| backend 컨테이너 | 폴링 | 30초 | 다운/재시작 | 🔴 장애 |
| frontend 컨테이너 | 폴링 | 30초 | 다운/재시작 | 🔴 장애 |
| nginx 컨테이너 | 폴링 | 30초 | 다운/재시작 | 🔴 장애 |
| db 컨테이너 | 폴링 | 30초 | 다운/재시작 | 🔴 장애 |
| GitHub Runner | 폴링 | 5분 | Offline | 🔴 장애 |
| WAS 에러 | 이벤트 | 즉시 | ERROR 발생 | 🔴 장애 |

### 5.2 임계값 설정 근거

| 항목 | 임계값 | 근거 |
|------|--------|------|
| CPU/RAM/SSD | 80% | 일반적인 운영 권고치, 여유분 확보 |
| 배터리 | 20% | 갑작스러운 전원 차단 방지 |

### 5.3 데이터 수집 정책

#### 하이브리드 방식 채택

| 구분 | 방식 | 데이터 | 목적 |
|------|------|--------|------|
| 헬스체크 | 상시 폴링 | 메모리 내 최근 10분 | 이상 감지 및 즉시 알람 |
| 상세 메트릭 | 온디맨드 | 대시보드 접속 시 수집 | 리소스 절약 |

**근거**:
- 상시 폴링만: 리소스 지속 사용
- 온디맨드만: 장애 감지 불가
- 하이브리드: 최소 리소스로 장애 감지 + 상세 정보 제공

---

## 6. 저장소 구조

### 6.1 모노레포 vs 멀티레포

| 구분 | 모노레포 (기존 repo) | 멀티레포 (별도 repo) |
|------|---------------------|---------------------|
| 관리 포인트 | 1개 | 2개 |
| CI/CD | paths 필터로 분리 | 독립 |
| 공통 코드 | 쉽게 공유 | 별도 라이브러리화 필요 |

### 6.2 결정: 모노레포 (Gradle 멀티모듈)

| 근거 | 설명 |
|------|------|
| 팀 규모 | 10인 미만 소규모, 모노레포 관리 충분 |
| 관리 효율 | 단일 저장소로 PR/이슈 통합 관리 |
| 공유 용이 | 추후 공통 코드 발생 시 쉽게 공유 |

### 6.3 프로젝트 구조

```
erp-project/
├── build.gradle.kts
├── settings.gradle.kts
├── backend/                  # 기존 ERP 백엔드
│   ├── build.gradle.kts
│   └── src/
├── frontend/                 # 기존 프론트엔드
│   └── ...
├── monitoring/               # 모니터링 모듈 (신규)
│   ├── build.gradle.kts
│   └── src/
└── .github/
    └── workflows/
        ├── backend.yml       # paths: backend/**
        └── monitoring.yml    # paths: monitoring/**
```

---

## 7. 시스템 아키텍처

```
┌─────────────────────────────────────────────────────────────┐
│                        노트북                                │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   ┌─────────────────────────────────────────────────────┐   │
│   │         모니터링 서비스 (JAR + systemd)              │   │
│   │         ~100MB RAM                                   │   │
│   ├─────────────────────────────────────────────────────┤   │
│   │                                                      │   │
│   │  ┌──────────────┐    ┌──────────────────────────┐   │   │
│   │  │ HealthChecker│    │ /admin/monitoring        │   │   │
│   │  │ (@Scheduled) │    │ (웹 대시보드)             │   │   │
│   │  │              │    │ IP 화이트리스트 적용      │   │   │
│   │  │ • OSHI       │    └──────────────────────────┘   │   │
│   │  │ • docker-java│                                   │   │
│   │  │ • GitHub API │                                   │   │
│   │  └──────┬───────┘                                   │   │
│   │         │                                           │   │
│   │         ▼                                           │   │
│   │  ┌──────────────────────────────────────────────┐   │   │
│   │  │              AlertService                     │   │   │
│   │  │  • Slack Webhook 발송                        │   │   │
│   │  │  • 알람 이력 저장 (메모리, 최근 100건)        │   │   │
│   │  └──────────────────────────────────────────────┘   │   │
│   │                                                      │   │
│   └─────────────────────────────────────────────────────┘   │
│                          │                                  │
│                          │ 감시                             │
│                          ▼                                  │
│   ┌─────────────────────────────────────────────────────┐   │
│   │                    Docker                            │   │
│   │  ┌────────┐ ┌────────┐ ┌────────┐ ┌──────────────┐  │   │
│   │  │backend │ │frontend│ │ nginx  │ │  PostgreSQL  │  │   │
│   │  └────────┘ └────────┘ └────────┘ └──────────────┘  │   │
│   └─────────────────────────────────────────────────────┘   │
│                                                             │
│   ┌─────────────────┐                                       │
│   │  GitHub Runner  │                                       │
│   └─────────────────┘                                       │
│                                                             │
└─────────────────────────────────────────────────────────────┘
              │
              │ 알람
              ▼
         ┌─────────┐
         │  Slack  │
         └─────────┘
```

---

## 8. 리소스 영향 분석

### 8.1 예상 메모리 사용량

| 구성요소 | 예상 RAM | 비고 |
|----------|----------|------|
| Spring Boot (최적화) | ~80MB | 불필요한 의존성 제거 |
| OSHI | ~5MB | 라이브러리 |
| 헬스체크 스케줄러 | ~10MB | 30초~1분 간격 |
| 알람 이력 (100건) | ~1MB | 메모리 보관 |
| **합계** | **~100MB** | 목표 범위 내 |

### 8.2 JVM 최적화 옵션 (권장)

```bash
java -Xms64m -Xmx128m -XX:+UseG1GC -jar monitoring.jar
```

---

## 9. 의존성 목록

```kotlin
// build.gradle.kts (monitoring 모듈)

dependencies {
    // Spring Boot
    implementation("org.springframework.boot:spring-boot-starter-web")
    implementation("org.springframework.boot:spring-boot-starter-actuator")

    // 시스템 리소스
    implementation("com.github.oshi:oshi-core:6.4.0")

    // Docker
    implementation("com.github.docker-java:docker-java-core:3.3.4")
    implementation("com.github.docker-java:docker-java-transport-httpclient5:3.3.4")

    // Kotlin
    implementation("com.fasterxml.jackson.module:jackson-module-kotlin")
    implementation("org.jetbrains.kotlin:kotlin-reflect")
}
```

---

## 10. 설정 항목

### 10.1 application.yml 예시

```yaml
monitoring:
  # 접근 제어
  allowed-ips:
    - 127.0.0.1
    - 192.168.0.100  # 관리자 PC IP

  # 임계값
  thresholds:
    cpu: 80
    ram: 80
    ssd: 80
    battery: 20

  # 수집 주기 (밀리초)
  intervals:
    system-resource: 60000   # 1분
    docker: 30000            # 30초
    github-runner: 300000    # 5분

  # Slack
  slack:
    webhook-url: ${SLACK_WEBHOOK_URL}
    channel: "#erp-alerts"

  # GitHub
  github:
    token: ${GITHUB_PAT}
    owner: "your-org"
    repo: "erp-project"
```

---

## 11. 준비물 체크리스트

| 항목 | 필요 작업 |
|------|-----------|
| Slack Webhook URL | 워크스페이스에서 Incoming Webhook 생성 |
| GitHub PAT | Runner 상태 조회 권한 포함하여 발급 |
| 관리자 PC IP | 고정 IP 확인 또는 대역 설정 |

---

## 12. 참고: 생략된 기술과 이유

| 기술 | 생략 이유 |
|------|-----------|
| Prometheus | 시계열 DB 불필요, RAM 부족 |
| Grafana | 대시보드 볼 사용자 소수 |
| ELK Stack | RAM 8GB로 불가능 (최소 12GB 필요) |
| Jaeger/Pinpoint | 단일 서버, 분산 추적 불필요 |
| Alertmanager | 온콜 로테이션 불필요 |
| Sentry | 외부 의존성 최소화 |

---

## 변경 이력

| 버전 | 날짜 | 작성자 | 내용 |
|------|------|--------|------|
| 1.0 | 2026-01-30 | - | 최초 작성 |